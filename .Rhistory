}
#' outputting the desired plot
#' @param my_path_plot (char): path of the where the plot will be saved on disk
#' @param my_width (int): pixel width of saved plot
#' @param my_height (int): pixel height of saved plot
#' @param my_point_size (int): point size of saved plot
#' @param my_quality (int): quality of saved plot
#'
#' @description show plot determined by my_plotting_function and save it on disk
#'
#' @return None
PlotAndSave = function(my_plotting_function,
my_path_plot,
my_width = FIGURE_WIDTH,
my_height = FIGURE_HEIGHT,
my_point_size = FIGURE_POINT_SIZE,
my_quality = FIGURE_QUALITY){
# call to shown plot
my_plotting_function()
# plot saved on disk
jpeg(my_path_plot,
width = my_width, height = my_height,
pointsize = my_point_size, quality = my_quality)
# call to saved plot
my_plotting_function()
dev.off()
}
CvMetricBest = function(my_param_values, my_metric_matrix,
my_se_matrix = 0,
my_metric_names,
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
indexes_metric_max = NULL){
# this code is sub-optimal, someday I'll change it
# compute standard deviations matrix lower and upper
se_lower = my_metric_matrix - my_se_matrix
se_upper = my_metric_matrix + my_se_matrix
# BEST PARAM VALUES section
n_col_metric_matrix = NCOL(my_metric_matrix)
best_params = rep(NA, n_col_metric_matrix)
names(best_params) = my_metric_names
# Check metrics min and max best
if(is.null(indexes_metric_max)){
indexes_best_params = apply(my_metric_matrix, 2, which.min)
}
else{
indexes_best_params = c(apply(my_metric_matrix[,-indexes_metric_max], 2, which.min),
apply(my_metric_matrix[,indexes_metric_max], 2, which.max))
}
if(my_one_se_best == TRUE){
# non efficient procedure, but we assume the parameter space is small
# find all indexes for which the best error is inside the 1se band
for(i in 1:length(indexes_best_params)){
# more readable code
temp_best_metric = my_metric_matrix[indexes_best_params[i], i]
# parameter indexes for which the metric is inside the 1se band of best param metric
temp_param_indexes = which(my_param_values %in% my_param_values[which(temp_best_metric > se_lower[,i] &
temp_best_metric < se_upper[,i])])
if(my_higher_more_complex == TRUE){
indexes_best_params[i]= temp_param_indexes[which.min(lambda_vals[temp_param_indexes])]
}
if(my_higher_more_complex == FALSE){
indexes_best_params[i]= temp_param_indexes[which.max(lambda_vals[temp_param_indexes])]
}
}
}
best_params = my_param_values[indexes_best_params]
# return indexes and best param values
returned_list = list()
# cycle over all metrics
for (i in 1:n_col_metric_matrix){
# add index
returned_list[[my_metric_names[i]]][["best_param_index"]] = indexes_best_params[i]
# add param value
returned_list[[my_metric_names[i]]][["best_param_value"]] = best_params[i]
# add all metrics relative to that row (best param index row)
returned_list[[my_metric_names[i]]][["metric_values"]] = my_metric_matrix[indexes_best_params[i],]
}
return(returned_list)
}
source("loss_functions.R")
# in generale uso sia MAE che MSE
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MAE.Loss(y.pred, y.test, weights), MSE.Loss(y.pred, y.test, weights)))
}
# anche qua
df_metrics = data.frame(name = NA, MAE = NA, MSE = NA)
N_METRICS_df_metrics = NCOL(df_metrics) - 1
METRICS_NAMES = colnames(df_metrics[,-1])
# names used to extract the metric added to df_metrics
# change based on the spefific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "MSE"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# numero fold
K_FOLDS = 4
NROW_DF = NROW(dati)
# ordine casuale degli id
SHUFFLED_ID = sample(1:NROW_DF, NROW_DF)
id_matrix_cv = matrix(SHUFFLED_ID, ncol = K_FOLDS)
ID_CV_LIST = list()
for(j in 1:ncol(id_matrix_cv)){
ID_CV_LIST[[j]] = id_matrix_cv[,j]
}
rm(id_matrix_cv)
gc()
# controllo il resto della divisione
integer_division_cv = NROW_DF %/% K_FOLDS
modulo_cv = NROW_DF %% K_FOLDS
if(modulo_cv != 0){
ID_CV_LIST[[K_FOLDS]] = ID_CV_LIST[[K_FOLDS]][1:integer_division_cv]
}
CvMetricBest = function(my_param_values, my_metric_matrix,
my_se_matrix = 0,
my_metric_names,
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
indexes_metric_max = NULL){
# this code is sub-optimal, someday I'll change it
# compute standard deviations matrix lower and upper
se_lower = my_metric_matrix - my_se_matrix
se_upper = my_metric_matrix + my_se_matrix
# BEST PARAM VALUES section
n_col_metric_matrix = NCOL(my_metric_matrix)
best_params = rep(NA, n_col_metric_matrix)
names(best_params) = my_metric_names
# Check metrics min and max best
if(is.null(indexes_metric_max)){
indexes_best_params = apply(my_metric_matrix, 2, which.min)
}
else{
indexes_best_params = c(apply(my_metric_matrix[,-indexes_metric_max], 2, which.min),
apply(my_metric_matrix[,indexes_metric_max], 2, which.max))
}
if(my_one_se_best == TRUE){
# non efficient procedure, but we assume the parameter space is small
# find all indexes for which the best error is inside the 1se band
for(i in 1:length(indexes_best_params)){
# more readable code
temp_best_metric = my_metric_matrix[indexes_best_params[i], i]
# parameter indexes for which the metric is inside the 1se band of best param metric
temp_param_indexes = which(my_param_values %in% my_param_values[which(temp_best_metric > se_lower[,i] &
temp_best_metric < se_upper[,i])])
if(my_higher_more_complex == TRUE){
indexes_best_params[i]= temp_param_indexes[which.min(lambda_vals[temp_param_indexes])]
}
if(my_higher_more_complex == FALSE){
indexes_best_params[i]= temp_param_indexes[which.max(lambda_vals[temp_param_indexes])]
}
}
}
best_params = my_param_values[indexes_best_params]
# return indexes and best param values
returned_list = list()
# cycle over all metrics
for (i in 1:n_col_metric_matrix){
# add index
returned_list[[my_metric_names[i]]][["best_param_index"]] = indexes_best_params[i]
# add param value
returned_list[[my_metric_names[i]]][["best_param_value"]] = best_params[i]
# add all metrics relative to that row (best param index row)
returned_list[[my_metric_names[i]]][["metric_values"]] = my_metric_matrix[indexes_best_params[i],]
}
return(returned_list)
}
PlotCvMetrics = function(my_param_values, my_metric_matrix,
my_se_matrix = 0,
my_metric_names,
my_best_param_values = c(),
my_main = "Model metrics", my_xlab = "parameter", my_legend_coords = "topright",
my_xlim = NULL, my_ylim = NULL){
# compute standard deviations matrix lower and upper
se_lower = my_metric_matrix - my_se_matrix
se_upper = my_metric_matrix + my_se_matrix
# if xlim null use entire x axis (default)
if (is.null(my_xlim)){
my_xlim = c(min(my_param_values), max(my_param_values))
}
# if ylim is null use min and max over the entire matrix
if (is.null(my_ylim)){
my_ylim = c(min(se_lower), max(se_upper))
}
# plot showed
plot(my_param_values, my_metric_matrix[,1],
xlab = my_xlab, ylab = "metric",
main = my_main, pch = 16,
xlim = my_xlim,
ylim = my_ylim)
arrows(my_param_values, se_lower[,1],
my_param_values, se_upper[,1],
length = 0.03, angle = 90)
for (i in 2:NCOL(my_metric_matrix)){
points(my_param_values, my_metric_matrix[,i],
pch = 15 + i, col = i)
arrows(my_param_values, se_lower[,i],
my_param_values, se_upper[,i],
length = 0.03, angle = 90, col = i)
}
legend(my_legend_coords,
legend = my_metric_names,
col = 1:NCOL(my_metric_matrix),
pch = 15 + (1:NCOL(my_metric_matrix)))
# plot them
for (i in 1:length(my_best_param_values))
abline(v = my_best_param_values[i], col = i)
}
#' outputting the desired plot
#' @param my_path_plot (char): path of the where the plot will be saved on disk
#' @param my_width (int): pixel width of saved plot
#' @param my_height (int): pixel height of saved plot
#' @param my_point_size (int): point size of saved plot
#' @param my_quality (int): quality of saved plot
#'
#' @description show plot determined by my_plotting_function and save it on disk
#'
#' @return None
PlotAndSave = function(my_plotting_function,
my_path_plot,
my_width = FIGURE_WIDTH,
my_height = FIGURE_HEIGHT,
my_point_size = FIGURE_POINT_SIZE,
my_quality = FIGURE_QUALITY){
# call to shown plot
my_plotting_function()
# plot saved on disk
jpeg(my_path_plot,
width = my_width, height = my_height,
pointsize = my_point_size, quality = my_quality)
# call to saved plot
my_plotting_function()
dev.off()
}
# media
temp_err_matrix_cv = matrix(NA, nrow = K_FOLDS, ncol = N_METRICS_df_metrics)
colnames(temp_err_matrix_cv) = colnames(df_metrics[,-1])
for (i in 1:K_FOLDS){
temp_err_matrix_cv[i,] = USED.Metrics(mean(dati$y[unlist(ID_CV_LIST[-i])]),
dati$y[ID_CV_LIST[[i]]])
}
df_metrics = Add_Test_Metric(df_metrics,
"cv mean",
colMeans(temp_err_matrix_cv))
# mediana
temp_err_matrix_cv = matrix(NA, nrow = K_FOLDS, ncol = N_METRICS_df_metrics)
for (i in 1:K_FOLDS){
temp_err_matrix_cv[i,] = USED.Metrics(median(dati$y[unlist(ID_CV_LIST[-i])]),
dati$y[ID_CV_LIST[[i]]])
}
df_metrics = Add_Test_Metric(df_metrics,
"cv median",
colMeans(temp_err_matrix_cv))
df_metrics = na.omit(df_metrics)
df_metrics
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Ridge e Lasso ------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
library(glmnet)
#' @param my_y (vector): y glmnet argument
#' @param my_alpha (int): alpha passed to glmnet (0 -> ridge, 1 -> lasso)
#' @param my_lambda_vals (vector): vector of lambda used
#'
#'
#' @return (list): list of two matrix
#' the first contains the CV folds averaged metrics for each parameter value and each metric
#' the second the CV computet standard errors of those metrics
#' first matrix is accessed by "metrics"
#' second matrix is accessed by "se"
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv,
my_n_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Metrics(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics)
# metrics standard deviations matrix
cv_metrics_se = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_se) = my_metric_names
for (i in 1:my_n_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_se[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list("metrics" = cv_metrics,
"se" = cv_metrics_se))
}
library(Matrix)
# X_mm_no_interaction = model.matrix(formula_no_interaction_no_intercept, data = dati)
# sparsa
X_mm_no_interaction =  sparse.model.matrix(formula_no_interaction_no_intercept, data = dati)
# X_mm_yes_interaction = model.matrix(formula_yes_interaction_no_intercept, data = dati)
#sparsa
X_mm_yes_interaction =  sparse.model.matrix(formula_yes_interaction_no_intercept, data = dati)
# NO interaction
lambda_vals = glmnet(x = X_mm_no_interaction, y = dati$y,
alpha = 0, lambda.min.ratio = 1e-07)$lambda
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLDS,
my_id_list_cv = ID_CV_LIST,
my_n_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
ridge_no_int_best_summary = CvMetricBest(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = FALSE,
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_metric_names = METRICS_NAMES,
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
ridge_no_int_best_summary = CvMetricBest(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = FALSE,
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_metric_names = METRICS_NAMES)
temp_plot_function = function(){
PlotCvMetrics(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda")
}
PlotAndSave(temp_plot_function, my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(temp_plot_function, my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
for(i in 1:length(ridge_no_int_best_summary)){print(ridge_no_int_best_summary[[i]])}
for(i in 1:length(ridge_no_int_best_summary)){print(ridge_no_int_best_summary[[i]]$best_param_value)}
#' @description extract a the vector of best parameter for each metric
#' from the output of CvMetricBest (list)
#' @param my_cv_metric_best_object (list): each element corresponds
#' to the name of the metric (ex. MSE) and the best parameter is accessed
#' by my_cv_metric_best_object[[i]]$best_param_value, where i is a generic index
#'
#' @return vector of best params
ExtractBestParams = function(my_cv_metric_best_object){
best_params_vector = rep(NA, length(my_cv_metric_best_object))
for (i in 1:length(my_cv_metric_best_object)){
best_params_vector[i] = my_cv_metric_best_object[[i]]$best_param_value
}
return(best_params_vector)
}
CvMetricBest = function(my_param_values, my_metric_matrix,
my_se_matrix = 0,
my_metric_names,
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
indexes_metric_max = NULL){
# this code is sub-optimal, someday I'll change it
# compute standard deviations matrix lower and upper
se_lower = my_metric_matrix - my_se_matrix
se_upper = my_metric_matrix + my_se_matrix
# BEST PARAM VALUES section
n_col_metric_matrix = NCOL(my_metric_matrix)
best_params = rep(NA, n_col_metric_matrix)
names(best_params) = my_metric_names
# Check metrics min and max best
if(is.null(indexes_metric_max)){
indexes_best_params = apply(my_metric_matrix, 2, which.min)
}
else{
indexes_best_params = c(apply(my_metric_matrix[,-indexes_metric_max], 2, which.min),
apply(my_metric_matrix[,indexes_metric_max], 2, which.max))
}
if(my_one_se_best == TRUE){
# non efficient procedure, but we assume the parameter space is small
# find all indexes for which the best error is inside the 1se band
for(i in 1:length(indexes_best_params)){
# more readable code
temp_best_metric = my_metric_matrix[indexes_best_params[i], i]
# parameter indexes for which the metric is inside the 1se band of best param metric
temp_param_indexes = which(my_param_values %in% my_param_values[which(temp_best_metric > se_lower[,i] &
temp_best_metric < se_upper[,i])])
if(my_higher_more_complex == TRUE){
indexes_best_params[i]= temp_param_indexes[which.min(lambda_vals[temp_param_indexes])]
}
if(my_higher_more_complex == FALSE){
indexes_best_params[i]= temp_param_indexes[which.max(lambda_vals[temp_param_indexes])]
}
}
}
best_params = my_param_values[indexes_best_params]
# return indexes and best param values
returned_list = list()
# cycle over all metrics
for (i in 1:n_col_metric_matrix){
# add index
returned_list[[my_metric_names[i]]][["best_param_index"]] = indexes_best_params[i]
# add param value
returned_list[[my_metric_names[i]]][["best_param_value"]] = best_params[i]
# add all metrics relative to that row (best param index row)
returned_list[[my_metric_names[i]]][["metric_values"]] = my_metric_matrix[indexes_best_params[i],]
}
return(returned_list)
}
#' @description extract a the vector of best parameter for each metric
#' from the output of CvMetricBest (list)
#' @param my_cv_metric_best_object (list): each element corresponds
#' to the name of the metric (ex. MSE) and the best parameter is accessed
#' by my_cv_metric_best_object[[i]]$best_param_value, where i is a generic index
#'
#' @return vector of best params
ExtractBestParams = function(my_cv_metric_best_object){
best_params_vector = rep(NA, length(my_cv_metric_best_object))
for (i in 1:length(my_cv_metric_best_object)){
best_params_vector[i] = my_cv_metric_best_object[[i]]$best_param_value
}
return(best_params_vector)
}
PlotCvMetrics = function(my_param_values, my_metric_matrix,
my_se_matrix = 0,
my_metric_names,
my_best_param_values = c(),
my_main = "Model metrics", my_xlab = "parameter", my_legend_coords = "topright",
my_xlim = NULL, my_ylim = NULL){
# compute standard deviations matrix lower and upper
se_lower = my_metric_matrix - my_se_matrix
se_upper = my_metric_matrix + my_se_matrix
# if xlim null use entire x axis (default)
if (is.null(my_xlim)){
my_xlim = c(min(my_param_values), max(my_param_values))
}
# if ylim is null use min and max over the entire matrix
if (is.null(my_ylim)){
my_ylim = c(min(se_lower), max(se_upper))
}
# plot showed
plot(my_param_values, my_metric_matrix[,1],
xlab = my_xlab, ylab = "metric",
main = my_main, pch = 16,
xlim = my_xlim,
ylim = my_ylim)
arrows(my_param_values, se_lower[,1],
my_param_values, se_upper[,1],
length = 0.03, angle = 90)
for (i in 2:NCOL(my_metric_matrix)){
points(my_param_values, my_metric_matrix[,i],
pch = 15 + i, col = i)
arrows(my_param_values, se_lower[,i],
my_param_values, se_upper[,i],
length = 0.03, angle = 90, col = i)
}
legend(my_legend_coords,
legend = my_metric_names,
col = 1:NCOL(my_metric_matrix),
pch = 15 + (1:NCOL(my_metric_matrix)))
# plot them
for (i in 1:length(my_best_param_values))
abline(v = my_best_param_values[i], col = i)
}
#' outputting the desired plot
#' @param my_path_plot (char): path of the where the plot will be saved on disk
#' @param my_width (int): pixel width of saved plot
#' @param my_height (int): pixel height of saved plot
#' @param my_point_size (int): point size of saved plot
#' @param my_quality (int): quality of saved plot
#'
#' @description show plot determined by my_plotting_function and save it on disk
#'
#' @return None
PlotAndSave = function(my_plotting_function,
my_path_plot,
my_width = FIGURE_WIDTH,
my_height = FIGURE_HEIGHT,
my_point_size = FIGURE_POINT_SIZE,
my_quality = FIGURE_QUALITY){
# call to shown plot
my_plotting_function()
# plot saved on disk
jpeg(my_path_plot,
width = my_width, height = my_height,
pointsize = my_point_size, quality = my_quality)
# call to saved plot
my_plotting_function()
dev.off()
}
temp_plot_function = function(){
PlotCvMetrics(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_best_param_values = ExtractBestParams(ridge_no_int_best_summary),
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda")
}
PlotAndSave(temp_plot_function, my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(temp_plot_function, my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
