# @param var_vector: vettore di variabile quantitativa con eventuali NA
# @param my_breaks vettore di separazione: default NA
# @param my_probs vettore di quantili: default quartili
# @return: vettore di character della variabile categorizzata per quantili
# + modalità EMPTY al posto dei NA
ToCategoricalIncludeNA = function(var_vector,
my_breaks = NA,
my_probs = seq(0, 1, 0.25)){
NOT_NA_index = which(!is.na(var_vector))
used_breaks = my_breaks
# default
if(is.na(my_breaks)){
used_breaks = quantile(var_vector, probs = my_probs, na.rm = TRUE)
}
to_breaks = as.character(cut(var_vector[NOT_NA_index],
breaks = unique(used_breaks),
include.lowest = TRUE))
returned_vector = rep("EMPTY", length(var_vector))
returned_vector[NOT_NA_index] = to_breaks
return(returned_vector)
}
# test
# ToCategoricalIncludeNA(c(1,2,NA,4,5,NA))
# lista di variabili quantitative da trasformare in qualitative
var_names_to_qual = colnames(dati[,which(relative_missing_freqs >= temp_threshold)])
var_names_to_qual
if(length(var_names_to_qual) != 0){
# attenzione agli eventuali valori di default in ToCategoricalIncludeNA
dati[,var_names_to_qual] = apply(dati[,var_names_to_qual], 2,
function(col) ToCategoricalIncludeNA(col))
}
rm(temp_threshold)
str(dati)
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Valori unici ---------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
var_names = colnames(dati)
y_index = which(var_names == "y")
# +++++++++++++++++++++++++++++++++++++++++++++++++
# Individuo qualitative codificate come quantitative
# ++++++++++++++++++++++++++++++++++++++++++++++++++
# ottieni l'indice delle colonne delle variabili con il numero di modalità
# da eventualmente convertire in fattori
# !!!!RICHIESTA ATTENZIONE!!!!!
unique_vals_df = data.frame(nome = rep("", NCOL(dati)),
indice = rep(0, NCOL(dati)),
uniques = rep(0, NCOL(dati)))
unique_vals_df$nome = colnames(dati)
unique_vals_df$indice = as.numeric(1:NCOL(dati))
unique_vals_df$uniques = as.numeric(apply(dati, 2, function(col) length(unique(col))))
unique_vals_df
# eslcusione della y
unique_vals_df_no_y = unique_vals_df[-which(unique_vals_df$nome == "y"),]
unique_vals_df_no_y
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Riduzione categorie qualitative -------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Funzioni
# ===================================================================
# @input my_table(table)
# @input first (int): how many values frequencies one should print (default all)
# @input print_lenght (bool): print the number of total unique values
# @return values frequency in decreasing frequency order
ReturnFirstTable = function(my_table,
first = NULL,
print_length = FALSE){
if (print_length == TRUE){
print(paste("number of unique values: ", length(my_table)))
}
# print all
if(is.null(first)){
first = length(my_table)
return(my_table  %>% sort(decreasing = T))
}
# print only first
else{
return((my_table  %>% sort(decreasing = T))[1:min(first,length(my_table))])
}
}
# @input my_df (data.frame)
# @input var_index_subset (vector of int): indexes of variables subset
# @input first (int): how many values frequencies one should print (default all)
# @input print_lenght (bool): print the number of total unique values
# @print values frequency in decreasing frequency order
# going forward with the "enter" input and backward with the "b" input
PrintAllTables = function(my_df,
var_index_subset = NULL,
first = NULL,
print_length = FALSE){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
print("--------------------------------------------")
print(var_names_temp[var_index_subset[var_index_counter]])
print(PrintFirstTable(table(my_df[,var_index_subset[var_index_counter]]),
first,
print_length))
print("--------------------------------------------")}
}
# Analisi prime 40 frequenze delle modalità di tutte
# le variabili
PrintAllTables(dati, first = 40)
PrintAllTables = function(my_df,
var_index_subset = NULL,
first = NULL,
print_length = FALSE){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
print("--------------------------------------------")
print(var_names_temp[var_index_subset[var_index_counter]])
print(ReturnFirstTable(table(my_df[,var_index_subset[var_index_counter]]),
first,
print_length))
print("--------------------------------------------")}
}
PrintAllTables(dati, first = 40)
RaggruppaModalita = function(df, var_name, tabella_freq_modalita, soglia, valore_nuova){
# modalità al di sotto di una certa frequenza
modalita_sotto_soglia = names(which(tabella_freq_modalita < soglia))
# raggruppo queste modalità
return(ifelse(df[,var_name] %in% modalita_sotto_soglia, valore_nuova, df[,var_name]))
}
# ==========================================================================================
# Attenzione: l'implementazione di tree NON permette esplicative
# categoriali con più di 30 modalità
# quindi eventualmente ridurre a max 30 modalità
# (compromesso di perdita informazione)
# ================================================================================
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Riduzione modalità qualitative per frequenza ----------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Esempio di applicazione: cambiare il nome della variabile e la soglia
# ==============================================================================
unique_vals_df_no_y
str(dati)
# Variabile singola ----------------
# °°°°°°°°°°°°°°°°°°°° Warning: cambia nome variabile °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
# Per una specifica variabile
# temp_table_freq = TableFreqFun(dati, "x5")
# temp_table_freq
#
# dati[,"x5"] = RaggruppaModalita(dati, "x5", temp_table_freq, 400, "Altro")
#
# # check
# temp_table_freq = TableFreqFun(dati, "x5")
# temp_table_freq
#
# rm(temp_table_freq)
# Tutte le variabili character ------------------------
# per motivi computazionali, al costo di perdere informazioni
# riduco le modalità a 25 modalità
# funzione per una singola variabile
GroupValuesQual = function(df, qual_vector_var_name, new_name = "Altro"){
temp_table_freq = TableFreqFun(df, qual_vector_var_name)
# meno di 30 modalità: non c'è bisogno di nessuna modifica
if (length(temp_table_freq) <= 25){
return(df[, qual_vector_var_name])
}
# altrimenti riduci le modalità
# seleziona la frequenza soglia oltre cui aggregare
# (temp_table_freq è già ordinata in ordine decrescente per frequenza)
freq_threshold = temp_table_freq[24]
return(RaggruppaModalita(df, qual_vector_var_name, temp_table_freq,
freq_threshold, new_name))
}
char_var_names = colnames(dati[,-y_index])[which(unlist(lapply(dati[,-y_index], typeof)) == "character")]
for(name in char_var_names){
dati[,name] = GroupValuesQual(dati, name, "Altro")
}
# funzione per una singola variabile
GroupValuesQual = function(df, qual_vector_var_name, new_name = "Altro"){
temp_table_freq = table(df[,qual_vector_var_name]) %>% sort(decreasing = T)
# meno di 30 modalità: non c'è bisogno di nessuna modifica
if (length(temp_table_freq) <= 25){
return(df[, qual_vector_var_name])
}
# altrimenti riduci le modalità
# seleziona la frequenza soglia oltre cui aggregare
# (temp_table_freq è già ordinata in ordine decrescente per frequenza)
freq_threshold = temp_table_freq[24]
return(RaggruppaModalita(df, qual_vector_var_name, temp_table_freq,
freq_threshold, new_name))
}
char_var_names = colnames(dati[,-y_index])[which(unlist(lapply(dati[,-y_index], typeof)) == "character")]
for(name in char_var_names){
dati[,name] = GroupValuesQual(dati, name, "Altro")
}
str(dati)
# check
unique_vals_df = data.frame(nome = rep("", NCOL(dati)),
indice = rep(0, NCOL(dati)),
uniques = rep(0, NCOL(dati)))
unique_vals_df$nome = colnames(dati)
unique_vals_df$indice = as.numeric(1:NCOL(dati))
unique_vals_df$uniques = as.numeric(apply(dati, 2, function(col) length(unique(col))))
unique_vals_df
# eslcusione della y
unique_vals_df_no_y = unique_vals_df[-which(unique_vals_df$nome == "y"),]
unique_vals_df_no_y
# indici delle esplicative con meno di min_modalità modalità
# da aumentare in base al problema
min_modalita = 2
# indici delle esplicative con meno di min_modalità modalità
# da aumentare in base al problema
min_modalita = 2
index_min_modalita = unique_vals_df_no_y$indice[which(unique_vals_df_no_y$uniques <= min_modalita)]
index_min_modalita
# trasformo in fattore queste ultime
for(i in index_min_modalita){
dati[,i] = as.factor(dati[,i])
}
str(dati)
var_factor_index = which(sapply(dati, is.factor))
# se comprende l'indice della y  lo rimuovo
# da sistemare
if (y_index %in% var_factor_index){
var_factor_index = var_factor_index[-which(var_factor_index == y_index)]}
var_char_index = which(sapply(dati, is.character))
# se comprende l'indice della y  lo rimuovo
# da sistemare
if (y_index %in% var_char_index){
var_char_index = var_char_index[-which(var_char_index == y_index)]}
# comprende anche int
var_num_index = as.numeric(which(sapply(dati, is.numeric)))
# se comprende l'indice della y lo rimuovo
if (y_index %in% var_num_index){
var_num_index = var_num_index[-which(var_num_index == y_index)]}
for(i in var_char_index){
dati[,i] = as.factor(dati[,i])
}
str(dati)
var_qual_index =  as.numeric(c(var_char_index, var_factor_index))
var_qual_names = var_names[var_qual_index]
var_num_names = var_names[var_num_index]
# check
var_qual_index
var_num_index
var_qual_names
var_num_names
# @input: my_df (data.frame)
# @input var_index_subset (vector of int): indexes of quantitative variables subset
# output: plots of each quantitative variable histogram
DrawQuantHist = function(my_df,
var_index_subset = NULL,
my_breaks = 50){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
par(mfrow(1,2))
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
# original scale
hist(my_df[,var_index_subset[var_index_counter]],
breaks = my_breaks,
main = var_names_temp[var_index_subset[var_index_counter]])
# log translated scale
temp_min = min(my_df[,var_index_subset[var_index_counter]])
if(temp_min > 0){
temp_min = 0}
hist(log(my_df[,var_index_subset[var_index_counter]] - temp_min + 1e-05 ),
breaks = my_breaks,
main = paste("log", var_names_temp[var_index_subset[var_index_counter]]))
}
par(mfrow(1,1))
}
# Analisi istogrammi
DrawQuantHist(dati, var_num_index)
# @input: my_df (data.frame)
# @input var_index_subset (vector of int): indexes of quantitative variables subset
# output: plots of each quantitative variable histogram
DrawQuantHist = function(my_df,
var_index_subset = NULL,
my_breaks = 50){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
par(mfrow = c(1,2))
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
# original scale
hist(my_df[,var_index_subset[var_index_counter]],
breaks = my_breaks,
main = var_names_temp[var_index_subset[var_index_counter]])
# log translated scale
temp_min = min(my_df[,var_index_subset[var_index_counter]])
if(temp_min > 0){
temp_min = 0}
hist(log(my_df[,var_index_subset[var_index_counter]] - temp_min + 1e-05 ),
breaks = my_breaks,
main = paste("log", var_names_temp[var_index_subset[var_index_counter]]))
}
par(mfrow = c(1,1))
}
# Analisi istogrammi
DrawQuantHist(dati, var_num_index)
# @input: my_df (data.frame)
# @input var_index_subset (vector of int): indexes of quantitative variables subset
# output: plots of each quantitative variable histogram
DrawQuantHist = function(my_df,
var_index_subset = NULL,
my_breaks = 50){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
par(mfrow = c(1,2))
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
# original scale
hist(my_df[,var_index_subset[var_index_counter]],
breaks = my_breaks,
main = var_names_temp[var_index_subset[var_index_counter]],
xlab = "")
# log translated scale
temp_min = min(my_df[,var_index_subset[var_index_counter]])
if(temp_min > 0){
temp_min = 0}
hist(log(my_df[,var_index_subset[var_index_counter]] - temp_min + 1e-05 ),
breaks = my_breaks,
main = paste("log", var_names_temp[var_index_subset[var_index_counter]]),
xlab = "")
}
par(mfrow = c(1,1))
}
# Analisi istogrammi
DrawQuantHist(dati, var_num_index)
# @input: my_df (data.frame)
# @input var_index_subset (vector of int): indexes of quantitative variables subset
# output: plots of each quantitative variable histogram
DrawQuantHist = function(my_df,
var_index_subset = NULL,
my_breaks = 50){
# all variables
if(is.null(var_index_subset)){
var_index_subset = 1:NCOL(my_df)}
var_index_counter = 0
var_names_temp = colnames(my_df)
par(mfrow = c(1,2))
print("press (enter) to forward and 'b' to backward and q to quit")
while(var_index_counter < length(var_index_subset)){
input = readline("")
if((input == "q")){
var_index_counter = length(var_index_subset) - 1}
if((input != "b")){
var_index_counter = var_index_counter + 1}
if(input == "b"){
var_index_counter = var_index_counter - 1}
if(var_index_counter <= 0){
var_index_counter = 1}
# original scale
hist(my_df[,var_index_subset[var_index_counter]],
breaks = my_breaks,
main = var_names_temp[var_index_subset[var_index_counter]],
xlab = "values")
# log translated scale
temp_min = min(my_df[,var_index_subset[var_index_counter]])
if(temp_min > 0){
temp_min = 0}
hist(log(my_df[,var_index_subset[var_index_counter]] - temp_min + 1e-05 ),
breaks = my_breaks,
main = paste("log", var_names_temp[var_index_subset[var_index_counter]]),
xlab = "log values")
}
par(mfrow = c(1,1))
}
# Analisi istogrammi
DrawQuantHist(dati, var_num_index)
# weights: solo per tasso di errata classificazione
tabella.sommario = function(previsti, osservati,
print_bool = FALSE,
weights = 1){
# inizializza: per evitare casi in cui la tabella non è 2x2
n <-  matrix(0, nrow = 2, ncol = 2)
for (i in 1:length(previsti)){
if(previsti[i] == osservati[i]){
# 0 == 0 case
if (previsti[i] == 0){
n[1,1] = n[1,1] + 1
}
# 1 == 1
else{
n[2,2] = n[2,2] + 1}
}
else{
# 0 != 1
if (previsti[i] == 0){
n[1,2] = n[1,2] + 1
}
# 1 != 0
else{
n[2,1] = n[2,1] + 1
}
}
}
err.tot <- sum((previsti != osservati) * weights)
zeros.observed = sum(n[1,1] + n[2,1])
ones.observed = sum(n[1,2] + n[2,2])
fn <- n[1,2]/ones.observed
fp <- n[2,1]/zeros.observed
tp = 1 - fn
tn = 1 - fp
f.score = 2*tp / (2*tp + fp + fn)
if(print_bool == TRUE){
print(n)
print(c("err tot", "fp", "fn", "f.score"))
print(c(err.tot, fp, fn, f.score))}
return(round(c(err.tot, fp, fn, f.score), 4))
}
tabella.sommario(c(0,1,1), c(0,1, 0))
# weights: solo per tasso di errata classificazione
tabella.sommario = function(previsti, osservati,
print_bool = FALSE,
weights = 1){
# inizializza: per evitare casi in cui la tabella non è 2x2
n <-  matrix(0, nrow = 2, ncol = 2)
for (i in 1:length(previsti)){
if(previsti[i] == osservati[i]){
# 0 == 0 case
if (previsti[i] == 0){
n[1,1] = n[1,1] + 1
}
# 1 == 1
else{
n[2,2] = n[2,2] + 1}
}
else{
# 0 != 1
if (previsti[i] == 0){
n[1,2] = n[1,2] + 1
}
# 1 != 0
else{
n[2,1] = n[2,1] + 1
}
}
}
err.tot <- sum((previsti != osservati) * weights) / sum(length(previsti) * weights)
zeros.observed = sum(n[1,1] + n[2,1])
ones.observed = sum(n[1,2] + n[2,2])
fn <- n[1,2]/ones.observed
fp <- n[2,1]/zeros.observed
tp = 1 - fn
tn = 1 - fp
f.score = 2*tp / (2*tp + fp + fn)
if(print_bool == TRUE){
print(n)
print(c("err tot", "fp", "fn", "f.score"))
print(c(err.tot, fp, fn, f.score))}
return(round(c(err.tot, fp, fn, f.score), 4))
}
tabella.sommario(c(0,1,1), c(0,1, 0))
tabella.sommario(c(0,1,1), c(0,1, 0), weights = c(1, 0, 0))
tabella.sommario(c(0,1,1), c(0,1, 0), weights = c(1, 0.8, 0.8))
