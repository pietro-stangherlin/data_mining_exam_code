my_data = dati,
my_max_size = TREE_MAX_SIZE)
tree_cv_metrics
#' @param my_data (data.frame): data.frame used
#'
#' @param my_max_size (int): max size of the pruned tree
#'
#' @param my_loss_functions (vector of characters): vector of loss function names feed to snowfall (parallel)
#' example  my_loss_functions = c("USED.Loss", "MAE.Loss", "MSE.Loss").
#' NOTE: if USED.Loss contains some other functions they must be present as well, like the example
#' which is also the default
#'
#' @return matrix of CV folds averaged errors for each parameter value and each loss function
FewDataCVCycleTreeParallelInner = function(n_k_fold, my_id_list_cv,my_n_metrics,
my_metric_names, my_data,
my_max_size = TREE_MAX_SIZE,
my_loss_functions = c("USED.Loss", "MAE.Loss", "MSE.Loss")){
# init parallel
sfInit(cpus = parallel::detectCores(), parallel = T)
sfLibrary(tree)
# we use my_max_size - 1 because we start with size = 2
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, my_max_size - 1, my_n_metrics))
# this has to be fixed with the losses actually used as a parameter
sfExport(list = c("my_data", my_loss_functions))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
# full grown tree
temp_tree_full = tree(y ~.,
data = my_data[id_train,],
control = tree.control(nobs = length(id_train),
mindev = 1e-05,
minsize = 2))
sfExport(list = c("temp_tree_full", "id_train", "id_test", "my_max_size"))
# if maximum tree depth error
# change minsize = 2 to higher values and so do it with
# mindev
# pruned tree: problem -> each fold can have different pruning inducing
# split sizes whose CV error cannot be averaged
# so I need to do it manually: select a set of size values
# for each value prune the full tree on the id_train (sub-optimal and too optimistic)
# (but given the scarsity of data we need a compromise)
# and keep track of the reduced deviance on the id_test
# for better readability
temp_metric = sfLapply(2:my_max_size,
fun = function(s)
USED.Loss(predict(prune.tree(temp_tree_full, best = s),
my_data[id_test,]), my_data$y[id_test]))
# unlist to the right dimensions matrix
temp_metrics_array_cv[k,(2:my_max_size)-1,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
rm(temp_tree_full)
rm(temp_metric)
gc()
print(paste("fold ", k))
}
cv_metrics = matrix(NA, nrow = (my_max_size - 1), ncol = my_n_metrics)
colnames(cv_metrics) = my_metric_names
for (i in 1:my_n_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
}
# stop parallel
sfStop()
rm(temp_metrics_array_cv)
gc()
return(cv_metrics)
}
tree_cv_metrics = FewDataCVCycleTreeParallelInner(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_max_size = TREE_MAX_SIZE)
tree_cv_metrics
TREE_MAX_SIZE = 50
# if parallel shows problem use the non parallel version
tree_cv_metrics = FewDataCVCycleTreeParallelInner(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_max_size = TREE_MAX_SIZE)
tree_best_summary = CvMetricPlotMin(my_param_values = 2:TREE_MAX_SIZE,
my_metric_matrix = tree_cv_metrics,
my_metric_names = METRICS_NAMES,
my_main = "Tree CV metrics",
my_xlab = "Size",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"tree_metrics_plot.jpeg"))
tree_best_summary
df_metrics = Add_Test_Metric(df_metrics,
"tree",
tree_best_summary[[METRIC_CHOSEN_NAME]][[METRIC_VALUES_NAME]])
df_metrics
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Ridge e Lasso ------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
library(glmnet)
library(Matrix)
# X_mm_no_interaction = model.matrix(formula_no_interaction_no_intercept, data = dati)
# sparsa
X_mm_no_interaction =  sparse.model.matrix(formula_no_interaction_no_intercept, data = dati)
# X_mm_yes_interaction = model.matrix(formula_yes_interaction_no_intercept, data = dati)
#sparsa
X_mm_yes_interaction =  sparse.model.matrix(formula_yes_interaction_no_intercept, data = dati)
# NO interaction
lambda_vals = glmnet(x = X_mm_no_interaction, y = dati$y,
alpha = 0, lambda.min.ratio = 1e-07)$lambda
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_err = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
# @return: matrix of CV folds averaged metrics for each parameter value and each metric
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(glmnet_cv_errs) = my_metric_names
for (i in 1:my_n_metrics_df_err){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
}
return(cv_metrics)
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_err = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
# @return: matrix of CV folds averaged metrics for each parameter value and each metric
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
}
return(cv_metrics)
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
ridge_no_interaction_metrics
# @return: matrix of CV folds averaged metrics for each parameter value and each metric
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list("metrics" = cv_metrics, "sd" = cv_metrics_sd))
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
ridge_no_int_best_summary = CvMetricPlotMin(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics$metrics,
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
ridge_no_int_best_summary = CvMetricPlotMin(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics$metrics,
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
ridge_no_interaction_metrics
# @return: matrix of CV folds averaged metrics for each parameter value and each metric
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_sd) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list("metrics" = cv_metrics, "sd" = cv_metrics_sd))
}
# names used for accessing list CV matrix (actual metrics and metrics sd)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "sd"
#'
#' @param  output_metric_list_element (char): name given to the list element matrix containing the metrics, use global variable
#' @param  output_sd_list_element (char): name given to the list element matrix containing the metrics standard errors, use global variable
#'
#'
#' @return (list): list of two matrix
#' the first contains the CV folds averaged metrics for each parameter value and each metric
#' the second the CV computet standard errors of those metrics
#' first matrix is accessed by output_metric_list_element name
#' second matrix is accessed by output_sd_list_element name
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals,
output_metric_list_element = "metrics",
output_sd_list_element = "sd"){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_sd) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list(output_metric_list_element = cv_metrics,
output_sd_list_element = cv_metrics_sd))
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals,
output_metric_list_element = LIST_METRICS_ACCESS_NAME,
output_sd_list_element = LIST_SD_ACCESS_NAME)
ridge_no_int_best_summary = CvMetricPlotMin(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[[LIST_METRICS_ACCESS_NAME]],
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
ridge_no_interaction_metrics
t = 5
eval(t)
#'
#' @param  output_metric_list_element (char): name given to the list element matrix containing the metrics, use global variable
#' @param  output_sd_list_element (char): name given to the list element matrix containing the metrics standard errors, use global variable
#'
#'
#' @return (list): list of two matrix
#' the first contains the CV folds averaged metrics for each parameter value and each metric
#' the second the CV computet standard errors of those metrics
#' first matrix is accessed by output_metric_list_element name
#' second matrix is accessed by output_sd_list_element name
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals,
output_metric_list_element = "metrics",
output_sd_list_element = "sd"){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_sd) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list(eval(output_metric_list_element) = cv_metrics,
#' @param my_y (vector): y glmnet argument
#' @param my_alpha (int): alpha passed to glmnet (0 -> ridge, 1 -> lasso)
#' @param my_lambda_vals (vector): vector of lambda used
#'
#'
#' @return (list): list of two matrix
#' the first contains the CV folds averaged metrics for each parameter value and each metric
#' the second the CV computet standard errors of those metrics
#' first matrix is accessed by "metrics"
#' second matrix is accessed by "sd"
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_sd) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list("metrics" = cv_metrics,
"sd" = cv_metrics_sd))
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals,
output_metric_list_element = LIST_METRICS_ACCESS_NAME,
output_sd_list_element = LIST_SD_ACCESS_NAME)
#' @param my_y (vector): y glmnet argument
#' @param my_alpha (int): alpha passed to glmnet (0 -> ridge, 1 -> lasso)
#' @param my_lambda_vals (vector): vector of lambda used
#'
#'
#' @return (list): list of two matrix
#' the first contains the CV folds averaged metrics for each parameter value and each metric
#' the second the CV computet standard errors of those metrics
#' first matrix is accessed by "metrics"
#' second matrix is accessed by "sd"
FewDataCVCycleGLMNET = function(n_k_fold, my_id_list_cv, my_n_metrics_df_metrics, my_metric_names,
my_x, my_y, my_alpha, my_lambda_vals){
temp_metrics_array_cv = array(NA, dim = c(n_k_fold, length(my_lambda_vals), my_n_metrics_df_metrics))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
temp_glmnet = glmnet(x = my_x[id_train,],
y = my_y[id_train], alpha = my_alpha,
lambda = my_lambda_vals)
temp_predictions = predict(temp_glmnet, my_x[id_test,])
for (j in 1:length(my_lambda_vals)){
temp_metrics_array_cv[k,j,] = USED.Loss(temp_predictions[,j], my_y[id_test])
}
rm(temp_glmnet)
rm(temp_predictions)
gc()
}
# averaged metrics matrix
cv_metrics = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
# metrics standard deviations matrix
cv_metrics_sd = matrix(NA, nrow = length(my_lambda_vals), ncol = my_n_metrics_df_metrics)
colnames(cv_metrics) = my_metric_names
colnames(cv_metrics_sd) = my_metric_names
for (i in 1:my_n_metrics_df_metrics){
cv_metrics[,i] = apply(temp_metrics_array_cv[,,i], 2, mean)
cv_metrics_sd[,i] = apply(temp_metrics_array_cv[,,i], 2, sd)
}
return(list("metrics" = cv_metrics,
"sd" = cv_metrics_sd))
}
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals,
output_metric_list_element = LIST_METRICS_ACCESS_NAME,
output_sd_list_element = LIST_SD_ACCESS_NAME)
ridge_no_interaction_metrics = FewDataCVCycleGLMNET(n_k_fold = K_FOLD,
my_id_list_cv = id_list_cv,
my_n_metrics_df_metrics = N_METRICS_df_metrics,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction,
my_y = dati$y,
my_alpha = 0,
my_lambda_vals = lambda_vals)
ridge_no_int_best_summary = CvMetricPlotMin(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
ridge_no_int_best_summary = CvMetricPlotMin(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = "lambda",
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
x = 1:10
x.sd = 0.1:1
x.sd
x.sd = (1:10)/10
x.sd
plot(x)
arrows(x+x.sd, x-x.sd)
?arrows
