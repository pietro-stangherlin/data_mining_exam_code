var_qual_index, var_qual_names,
var_num_index, var_num_names,
formula_no_interaction_no_intercept,
formula_no_interaction_yes_intercept,
formula_yes_interaction_no_intercept,
formula_yes_interaction_yes_intercept,
FIGURES_FOLDER_RELATIVE_PATH,
MODELS_FOLDER_RELATIVE_PATH,
file = "result_preprocessing.Rdata")
# if necessary delete all
# rm(list = ls())
# in case of problems: load only useful objects
# load("result_preprocessing.Rdata")
# ///////////////////////////////////
# Save output on file ---------------
# //////////////////////////////////
# text.txt -------------
# # close previoulsy opened sink (if opened) -> I should make a control
# sink()
# initialize the output .txt file to regularly write on in case
# the software crashes
# open new sink
TEXT_OUTPUT_FILE_NAME = "text_output_models.txt"
# open sink
sink(TEXT_OUTPUT_FILE_NAME, append = TRUE, split = TRUE)
# data wrangling
library(dplyr)
# parallel computing
library(snowfall)
# number of cores
N_CORES = parallel::detectCores()
load("result_preprocessing.Rdata")
#////////////////////////////////////////////////////////////////////////////
# Metrics and data.frame --------------------------------------------------
#////////////////////////////////////////////////////////////////////////////
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Quantitative response ---------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
source("loss_functions.R")
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), NA))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
filler = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
# /////////////////////////////////////////////////////////////////
#------------------------ Sottocampionamento ----------------------
# /////////////////////////////////////////////////////////////////
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Parameter tuning: cross validation on train: building cv folds  -------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
# NOTE: if the row number of sss is not a multiple of K_FOLDS
# the last fold repeats some ids from the first
# this is fixed in the code below
id_matrix_cv = matrix(SHUFFLED_ID, ncol = K_FOLDS)
# conversion of matrix in list of elements: each element contains a subset of ids
ID_CV_LIST_UNBALANCED = list()
for(j in 1:ncol(id_matrix_cv)){
ID_CV_LIST_UNBALANCED[[j]] = id_matrix_cv[,j]
}
rm(id_matrix_cv)
gc()
# repeated ids fixing
integer_division_cv = NROW_dati %/% K_FOLDS
modulo_cv = NROW_dati %% K_FOLDS
if(modulo_cv != 0){
ID_CV_LIST_UNBALANCED[[K_FOLDS]] = ID_CV_LIST_UNBALANCED[[K_FOLDS]][1:integer_division_cv]
}
ID_CV_LIST_BALANCED = ID_CV_LIST_UNBALANCED
# Balanced ID CV creation --------------
# CV_PROP = 0.5
#
#
# ID_CV_LIST_BALANCED = list()
#
# for(i in 1:length(ID_CV_LIST_UNBALANCED)){
#   # cambiare valori all'occorrenza
#   ids_few =ID_CV_LIST_UNBALANCED[[i]][which(dati$y[ID_CV_LIST_UNBALANCED[[i]]] == 1)]
#   ids_lot =ID_CV_LIST_UNBALANCED[[i]][which(dati$y[ID_CV_LIST_UNBALANCED[[i]]] == 0)]
#
#   tot = round(length(ids_few)/CV_PROP)
#
#   ID_CV_LIST_BALANCED[[i]] = c(ids_few,
#                                sample(ids_lot, size = tot - length(ids_few), replace = FALSE))
# }
#
#
#
#
#
# source("cv_functions.R")
#
# BALANCED_ID_vector = unlist(ID_CV_LIST_BALANCED)
# UNBALANCED_ID_vector = unlist(ID_CV_LIST_UNBALANCED)
source("cv_functions.R")
MY_WEIGHTS = rep(1, NROW_dati)
USE_ONLY_FIRST_FOLD = FALSE
library(nnet)
Y_dati = class.ind(dati$y)
Y_LEVELS_SORTED = colnames(Y_dati)
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Random Forest ------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
library(ranger)
# massimo numero di esplicative presenti
RF_MAX_VARIABLES = NCOL(dati) - 2 # sottraggo 1 per la variabile risposta
RF_ITER = 400
RF_TREE_NUMBER_SEQ = seq(10, 400, 10)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
rf_cv_metrics
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
filler = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
# NOTE: if the row number of sss is not a multiple of K_FOLDS
# the last fold repeats some ids from the first
# this is fixed in the code below
id_matrix_cv = matrix(SHUFFLED_ID, ncol = K_FOLDS)
# conversion of matrix in list of elements: each element contains a subset of ids
ID_CV_LIST_UNBALANCED = list()
for(j in 1:ncol(id_matrix_cv)){
ID_CV_LIST_UNBALANCED[[j]] = id_matrix_cv[,j]
}
rm(id_matrix_cv)
gc()
# repeated ids fixing
integer_division_cv = NROW_dati %/% K_FOLDS
modulo_cv = NROW_dati %% K_FOLDS
if(modulo_cv != 0){
ID_CV_LIST_UNBALANCED[[K_FOLDS]] = ID_CV_LIST_UNBALANCED[[K_FOLDS]][1:integer_division_cv]
}
ID_CV_LIST_BALANCED = ID_CV_LIST_UNBALANCED
source("cv_functions.R")
MY_WEIGHTS = rep(1, NROW_dati)
USE_ONLY_FIRST_FOLD = FALSE
library(nnet)
Y_dati = class.ind(dati$y)
Y_LEVELS_SORTED = colnames(Y_dati)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
# massimo numero di esplicative presenti
RF_MAX_VARIABLES = NCOL(dati) - 2 # sottraggo 1 per la variabile risposta
RF_ITER = 400
RF_TREE_NUMBER_SEQ = seq(10, 400, 10)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
rf_cv_metrics
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_metric_names = METRICS_NAMES)
rf_cv_metrics
rf_cv_metrics[["metrics"]]
rf_cv_metrics[["metrics"]][,1]
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_metric_names = METRICS_NAMES)
METRICS_NAMES_PLOT = colnames(df_metrics[,2])
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = colnames(df_metrics)
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = colnames(df_metrics)[2]
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = "missclass"
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES_PLOT )
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
METRICS_NAMES_PLOT = "missclass"
N_METRICS = length(METRICS_NAMES)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES )
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
METRICS_NAMES_PLOT = "missclass"
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
setwd("C:/Users/pietr/OneDrive - Università degli Studi di Padova/UNI/Corsi/Magistrale/Primo Anno/Secondo semestre/Data Mining/Exam used code templates/Exam Preparation Code")
rm(list = ls())
library(dplyr)
# Per Lapsus
# CTRL + C per commentare più righe di codice
# ///////////////////////////////////
# Save output on file ---------------
# //////////////////////////////////
# models.Rdata -------------
# relative path figures folder
MODELS_FOLDER_RELATIVE_PATH = "models/"
# this folder is used to store the best selected models on disk as .Rdata files
# so the main memory can be freed while fitting other models
# and they can be retrieved in the last analysis step
# Short function to save the .RData object
# text.txt -------------
# initialize the output txt file to regularly write on in case
# the software crashes
# also
# TEXT_OUTPUT_FILE_NAME = "text_output_preprocessing.txt"
#
# # open sink
# sink(TEXT_OUTPUT_FILE_NAME, append = TRUE, split = TRUE)
# figures folder ----------
# relative path figures folder
FIGURES_FOLDER_RELATIVE_PATH = "figures/"
# /////////////////////////////////////////////////////////////////////////////
#  ----------------------- Lettura e Preprocessing -----------------------------
# /////////////////////////////////////////////////////////////////////////////
# per avere un'idea del file da terminale:
# head nome_file.formato
dati = read.csv("test_dataset/df_multi.csv", sep = ",", stringsAsFactors = F)
# controllo
str(dati)
# rimuovo variabili con un solo valore
col_indexes = 1:NCOL(dati)
only_one_indexes = apply(dati, 2, function(col) length(unique(col)) == 1)
length(col_indexes[only_one_indexes])
if(length(col_indexes[only_one_indexes]) > 0){
dati = dati[,-col_indexes[only_one_indexes]]
}
# rinomimo la risposta in y: cambia il primo "y" in base al problema
names(dati)[which(names(dati) == "y")] = "y"
# controllo
str(dati)
library(ipred)
?bagging
