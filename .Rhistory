dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
ppr_metrics_cv = PPRRegulationCVParallel(my_data = sss,
my_id_list_cv = ID_CV_LIST,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#'
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationCVParallel = function(my_data = sss,
my_id_list_cv,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
n_k_fold = length(my_id_list_cv)
my_n_metrics = length(my_metrics_names)
# needed to do parallel
# each list element contains a vector of length 2
# first element is the number of ridge functions
# second element are the spline degrees of freedom
params_list = list()
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in my_spline_df){
params_list[[counter]] = c(r, df)
counter = counter + 1
}
}
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_max_ridge_functions", "my_spline_df", "params_list",
"my_weights"))
temp_metrics_array_cv = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
#' which is also the default
#'
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationCVParallel = function(my_data = sss,
my_id_list_cv,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
n_k_fold = length(my_id_list_cv)
my_n_metrics = length(my_metrics_names)
# needed to do parallel
# each list element contains a vector of length 2
# first element is the number of ridge functions
# second element are the spline degrees of freedom
params_list = list()
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in my_spline_df){
params_list[[counter]] = c(r, df)
counter = counter + 1
}
}
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_max_ridge_functions", "my_spline_df", "params_list",
"my_weights"))
temp_metrics_array_cv = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
ppr_metrics_cv = PPRRegulationCVParallel(my_data = sss,
my_id_list_cv = ID_CV_LIST,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#'
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationCVParallel = function(my_data = sss,
my_id_list_cv,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
n_k_fold = length(my_id_list_cv)
my_n_metrics = length(my_metrics_names)
# needed to do parallel
# each list element contains a vector of length 2
# first element is the number of ridge functions
# second element are the spline degrees of freedom
params_list = list()
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in my_spline_df){
params_list[[counter]] = c(r, df)
counter = counter + 1
}
}
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_max_ridge_functions", "my_spline_df", "params_list",
"my_weights"))
temp_metrics_array_cv = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
print("lol")
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
ppr_metrics_cv = PPRRegulationCVParallel(my_data = sss,
my_id_list_cv = ID_CV_LIST,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#'
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationCVParallel = function(my_data = sss,
my_id_list_cv,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
n_k_fold = length(my_id_list_cv)
my_n_metrics = length(my_metrics_names)
# needed to do parallel
# each list element contains a vector of length 2
# first element is the number of ridge functions
# second element are the spline degrees of freedom
params_list = list()
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in my_spline_df){
params_list[[counter]] = c(r, df)
counter = counter + 1
}
}
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_max_ridge_functions", "my_spline_df", "params_list",
"my_weights"))
temp_metrics_array_cv = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
print("lol")
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
print("lel")
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
ppr_metrics_cv = PPRRegulationCVParallel(my_data = sss,
my_id_list_cv = ID_CV_LIST,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#'
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationCVParallel = function(my_data = sss,
my_id_list_cv,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
n_k_fold = length(my_id_list_cv)
my_n_metrics = length(my_metrics_names)
# needed to do parallel
# each list element contains a vector of length 2
# first element is the number of ridge functions
# second element are the spline degrees of freedom
params_list = list()
counter = 1
for (r in 1:my_max_ridge_functions){
for(df in my_spline_df){
params_list[[counter]] = c(r, df)
counter = counter + 1
}
}
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_max_ridge_functions", "my_spline_df", "params_list",
"my_weights"))
temp_metrics_array_cv = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names),
n_k_fold),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names,
rep(NA, n_k_fold)))
print("lol")
for (k in 1:n_k_fold){
id_train = unlist(my_id_list_cv[-k])
id_test = my_id_list_cv[[k]]
sfExport(list = c("id_train", "id_test"))
temp_metric = sfLapply(params_list,
fun = function(el)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[id_train,],
nterms = el[1],
sm.method = "spline",
df = el[2]),
my_data[id_test,]), my_data$y[id_test],
weights = my_weights))
counter = 1
print("lul")
for (r in 1:my_max_ridge_functions){
for(df in 1:length(my_spline_df)){
temp_metrics_array_cv[r, df, ,k] = temp_metric[[counter]]
counter = counter + 1
}
}
print(paste("fold = ", k, collapse = ""))
}
print("lel")
metrics_array = array(0,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
# average over ridge functions
for(k in 1:n_k_fold){
metrics_array = metrics_array + temp_metrics_array_cv[, , ,k]
}
metrics_array = metrics_array / n_k_fold
rm(mod)
gc()
return(metrics_array)
}
ppr_metrics_cv = PPRRegulationCVParallel(my_data = sss,
my_id_list_cv = ID_CV_LIST,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
