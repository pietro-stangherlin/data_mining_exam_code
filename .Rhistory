row_missing_index_NA = which((apply(dati, 1, function(row)( NA %in% row))))
# se sono poche le elimino
length(row_missing_index_NA)
# elimino le righe con dati mancanti se sono poche
# rispetto alla numerosità campionaria
# soglia arbitraria -> da cambiare
length(row_missing_index_NA) / NROW(dati)
if((length(row_missing_index_NA) / NROW(dati)) < 0.05){
dati = dati[-row_missing_index_NA,]
}
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Valori mancanti NA Quantitative --------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Visto il tempo limitato adotto una delle seguenti opzioni:
# 1) eliminazione mancanti se sono pochi (in base al problema)
# 2) converto in classi i valori quantitativi e aggiungo la modalità EMPTY
# in corrispondenza dei NA
# Per risparmiare tempo discrimino quali variabili sottoporre a 1) o 2)
# in base alla frequenza relativa di NA (può cambiare da problema a problema):
# sotto una certa soglia adotto 1), sopra adotto 2)
relative_missing_freqs = missing_freq_NA / NROW(dati)
# seleziono le variabili con frequenza relativa di valori NA inferiore
# a una certa soglia prefissata
temp_threshold = 0.05
var_names_to_remove = colnames(dati[,which(relative_missing_freqs > 0 & relative_missing_freqs < temp_threshold)])
var_names_to_remove
if(length(var_names_to_remove != 0)){
row_missing_index_NA_to_remove = which((apply(dati[,var_names_to_remove], 1, function(row)( NA %in% row))))
dati = dati[-row_missing_index_NA_to_remove,]}
str(dati)
# 2)
# funzione per una di queste variabili
# @param var_vector: vettore di variabile quantitativa con eventuali NA
# @param my_breaks vettore di separazione: default NA
# @param my_probs vettore di quantili: default quartili
# @return: vettore di character della variabile categorizzata per quantili
# + modalità EMPTY al posto dei NA
ToCategoricalIncludeNA = function(var_vector,
my_breaks = NA,
my_probs = seq(0, 1, 0.25)){
NOT_NA_index = which(!is.na(var_vector))
used_breaks = my_breaks
# default
if(is.na(my_breaks)){
used_breaks = quantile(var_vector, probs = my_probs, na.rm = TRUE)
}
to_breaks = as.character(cut(var_vector[NOT_NA_index],
breaks = unique(used_breaks),
include.lowest = TRUE))
returned_vector = rep("EMPTY", length(var_vector))
returned_vector[NOT_NA_index] = to_breaks
return(returned_vector)
}
# test
# ToCategoricalIncludeNA(c(1,2,NA,4,5,NA))
# lista di variabili quantitative da trasformare in qualitative
var_names_to_qual = colnames(dati[,which(relative_missing_freqs >= temp_threshold)])
var_names_to_qual
if(length(var_names_to_qual) != 0){
# attenzione agli eventuali valori di default in ToCategoricalIncludeNA
dati[,var_names_to_qual] = apply(dati[,var_names_to_qual], 2,
function(col) ToCategoricalIncludeNA(col))
}
rm(temp_threshold)
str(dati)
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Valori unici ---------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
var_names = colnames(dati)
y_index = which(var_names == "y")
# +++++++++++++++++++++++++++++++++++++++++++++++++
# Individuo qualitative codificate come quantitative
# ++++++++++++++++++++++++++++++++++++++++++++++++++
# ottieni l'indice delle colonne delle variabili con il numero di modalità
# da eventualmente convertire in fattori
# !!!!RICHIESTA ATTENZIONE!!!!!
unique_vals_df = data.frame(nome = rep("", NCOL(dati)),
indice = rep(0, NCOL(dati)),
uniques = rep(0, NCOL(dati)))
unique_vals_df$nome = colnames(dati)
unique_vals_df$indice = as.numeric(1:NCOL(dati))
unique_vals_df$uniques = as.numeric(apply(dati, 2, function(col) length(unique(col))))
unique_vals_df
# eslcusione della y
unique_vals_df_no_y = unique_vals_df[-which(unique_vals_df$nome == "y"),]
unique_vals_df_no_y
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Riduzione categorie qualitative -------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Per variabili che so già essere qualitative
# Funzioni
# ===================================================================
# ritorna la tabella con le modalità e le rispettive frequenze
# per il data.frame df e la variabile var_name
TableFreqFun = function(df, var_name){
table_modalita_decr = table(df[,var_name]) %>% sort(decreasing = T)
# quante modalità
print("Numero di modalità uniche")
print( df[,var_name] %>% unique() %>% length())
return(table_modalita_decr)
}
# ritorna le modalità di var_name con frequenza minore di soglia
# con il "valore nuova"
# NOTA: il return DEVE essere ASSEGNATO
RaggruppaModalita = function(df, var_name, tabella_freq_modalita, soglia, valore_nuova){
# modalità al di sotto di una certa frequenza
modalita_sotto_soglia = names(which(tabella_freq_modalita < soglia))
# raggruppo queste modalità
return(ifelse(df[,var_name] %in% modalita_sotto_soglia, valore_nuova, df[,var_name]))
}
# ==========================================================================================
# Attenzione: l'implementazione di tree NON permette esplicative
# categoriali con più di 30 modalità
# quindi eventualmente ridurre a max 30 modalità
# (compromesso di perdita informazione)
# ================================================================================
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Riduzione modalità qualitative per frequenza ----------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Esempio di applicazione: cambiare il nome della variabile e la soglia
# ==============================================================================
unique_vals_df_no_y
str(dati)
# Variabile singola ----------------
# °°°°°°°°°°°°°°°°°°°° Warning: cambia nome variabile °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
# Per una specifica variabile
# temp_table_freq = TableFreqFun(dati, "x5")
# temp_table_freq
#
# dati[,"x5"] = RaggruppaModalita(dati, "x5", temp_table_freq, 400, "Altro")
#
# # check
# temp_table_freq = TableFreqFun(dati, "x5")
# temp_table_freq
#
# rm(temp_table_freq)
# Tutte le variabili character ------------------------
# per motivi computazionali, al costo di perdere informazioni
# riduco le modalità a 25 modalità
# funzione per una singola variabile
GroupValuesQual = function(df, qual_vector_var_name, new_name = "Altro"){
temp_table_freq = TableFreqFun(df, qual_vector_var_name)
# meno di 30 modalità: non c'è bisogno di nessuna modifica
if (length(temp_table_freq) <= 25){
return(df[, qual_vector_var_name])
}
# altrimenti riduci le modalità
# seleziona la frequenza soglia oltre cui aggregare
# (temp_table_freq è già ordinata in ordine decrescente per frequenza)
freq_threshold = temp_table_freq[24]
return(RaggruppaModalita(df, qual_vector_var_name, temp_table_freq,
freq_threshold, new_name))
}
char_var_names = colnames(dati[,-y_index])[which(unlist(lapply(dati[,-y_index], typeof)) == "character")]
for(name in char_var_names){
dati[,name] = GroupValuesQual(dati, name, "Altro")
}
str(dati)
# check
unique_vals_df = data.frame(nome = rep("", NCOL(dati)),
indice = rep(0, NCOL(dati)),
uniques = rep(0, NCOL(dati)))
unique_vals_df$nome = colnames(dati)
unique_vals_df$indice = as.numeric(1:NCOL(dati))
unique_vals_df$uniques = as.numeric(apply(dati, 2, function(col) length(unique(col))))
unique_vals_df
# eslcusione della y
unique_vals_df_no_y = unique_vals_df[-which(unique_vals_df$nome == "y"),]
unique_vals_df_no_y
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Riduzione quantitative in qualitative per poche modalità --------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# + qualitative che sono codificate numericamente
# indici delle esplicative con meno di min_modalità modalità
# da aumentare in base al problema
min_modalita = 2
index_min_modalita = unique_vals_df_no_y$indice[which(unique_vals_df_no_y$uniques <= min_modalita)]
index_min_modalita
# trasformo in fattore queste ultime
for(i in index_min_modalita){
dati[,i] = as.factor(dati[,i])
}
str(dati)
# +++++++++++++++++++++++++++++++++++++++++++++++++
# Nomi e indici di colonna delle variabili
# ++++++++++++++++++++++++++++++++++++++++++++++++++
# nomi delle esplicative qualitative e quantitative
# potrei dover effettuare questa operazione più volte
var_factor_index = which(sapply(dati, is.factor))
# se comprende l'indice della y  lo rimuovo
# da sistemare
if (y_index %in% var_factor_index){
var_factor_index = var_factor_index[-which(var_factor_index == y_index)]}
var_char_index = which(sapply(dati, is.character))
# se comprende l'indice della y  lo rimuovo
# da sistemare
if (y_index %in% var_char_index){
var_char_index = var_char_index[-which(var_char_index == y_index)]}
# comprende anche int
var_num_index = as.numeric(which(sapply(dati, is.numeric)))
# se comprende l'indice della y lo rimuovo
if (y_index %in% var_num_index){
var_num_index = var_num_index[-which(var_num_index == y_index)]}
# +++++++++++++++++++++++++++++++++++++++++++++++++
# Conversione character in factor
# ++++++++++++++++++++++++++++++++++++++++++++++++++
for(i in var_char_index){
dati[,i] = as.factor(dati[,i])
}
str(dati)
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Aggiorno indici qualitative e nomi qualitative e quantitative
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
var_qual_index =  as.numeric(c(var_char_index, var_factor_index))
var_qual_names = var_names[var_qual_index]
var_num_names = var_names[var_num_index]
# check
var_qual_index
var_num_index
var_qual_names
var_num_names
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Scope ----------------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Attenzione: solo per regressione o classificazione binaria
# funzione per creare le stringhe di interazione
# tra variabili della stessa tipologia
# (quantitativa - quantitativa e fattore - fattore)
# '@ input: array of strings
# '@ return string formula of interaction terms
# example :
# input = c("a", "b", "c")
# output = "a:b + a:c + b:c"
MakeSameInteractionsString = function(input_var_type_names){
# preliminary checks
if(length(input_var_type_names) == 0){
cat("Warning: input_var_type_names is of length 0, return empty string")
return("")
}
type_type_interactions_string = ""
for (i in 1:length(input_var_type_names)){
for (j in (i+1):length(input_var_type_names)){
if (!(is.na(input_var_type_names[i]) | is.na(input_var_type_names[j])) & (j != i))
type_type_interactions_string = paste(type_type_interactions_string,
" + ",
input_var_type_names[i],
":",
input_var_type_names[j])
}
}
# Remove the first " + " from the string
type_type_interactions_string = substring(type_type_interactions_string, 6)
return(type_type_interactions_string)
}
# stringhe intermedie
no_interaction_string = paste(var_names[-y_index], collapse = " + ")
qual_num_interactions_string = paste(outer(var_num_names,
var_qual_names,
FUN = function(x, y) paste(x, y, sep = ":")), collapse = " + ")
qual_qual_interactions_string = MakeSameInteractionsString(var_qual_names)
num_num_interactions_string = MakeSameInteractionsString(var_num_names)
# variabili quantitative al quadrato
num_vars_square_string = ""
if(length(var_num_names) != 0){
num_vars_square_string <- paste("I(",
var_num_names,
"^2)",
sep = "", collapse = " + ")}
# string terms vector: vector of string terms
# return formula object
MakeFormula = function(string_terms_vector, intercept_bool = TRUE){
base_formula = "y ~ "
# remove empty vector terms
string_terms_vector = string_terms_vector[which(string_terms_vector != "")]
if (intercept_bool == FALSE){
base_formula = paste(base_formula, " - 1 + ")
}
added_terms = paste(string_terms_vector, collapse = " + ")
return(as.formula(paste(base_formula, added_terms)))
}
# creazione delle formule
# per evitare errori dovuti a formule troppo lunghe
options(expressions = 50000)
formula_yes_interaction_yes_intercept <- MakeFormula(c(no_interaction_string,
num_vars_square_string,
qual_qual_interactions_string,
qual_num_interactions_string))
formula_yes_interaction_no_intercept <- MakeFormula(c(no_interaction_string,
num_vars_square_string,
qual_qual_interactions_string,
qual_num_interactions_string),
intercept_bool = FALSE)
formula_yes_interaction_yes_intercept
formula_yes_interaction_no_intercept
# formula senza interazioni
formula_no_interaction_yes_intercept = MakeFormula(no_interaction_string)
formula_no_interaction_no_intercept = MakeFormula(no_interaction_string, intercept_bool = FALSE)
formula_no_interaction_yes_intercept
formula_no_interaction_no_intercept
MissErr = function(previsti, osservati){
# check
if(length(previsti) != length(osservati)){
print("Warning: length(previsti) != length(osservati), return NULL")
print(paste("length(previsti) = " ,length(previsti),
"length(osservati) = ", length(osservati)))
return(NULL)
}
return( 1- sum(previsti == osservati) / length(previsti))
}
# test data: three classes and 5 units
# one
previsti_test = matrix(c(0, 1, 0,
1, 0, 0,
1, 0, 0,
0, 0, 1,
0, 1, 0,
), byrow = T)
# test data: three classes and 5 units
# one
previsti_test = matrix(c(0, 1, 0,
1, 0, 0,
1, 0, 0,
0, 0, 1,
0, 1, 0,
),ncol = 3,  byrow = T)
# test data: three classes and 5 units
# one
previsti_test = matrix(c(0, 1, 0,
1, 0, 0,
1, 0, 0,
0, 0, 1,
0, 1, 0
), ncol = 3,  byrow = T)
previsti_test
osservati_test = matrix(c(0, 1, 0,
0, 1, 0,
1, 0, 0,
0, 0, 1,
0, 1, 1),
ncol = 3,  byrow = T)
MissErr(previsti_test, osservati_test)
# input: matrices of zeros and ones
MissErr = function(previsti, osservati){
# check
if(NROW(previsti) != NROW(osservati)){
print("Warning: length(previsti) != length(osservati), return NULL")
print(paste("NROW(previsti) = ", NROW(previsti),
"NROW(osservati) = ", NROW(osservati)))
return(NULL)
}
return( 1- sum(previsti == osservati) / length(previsti))
}
# test data: three classes and 5 units
# one
previsti_test = matrix(c(0, 1, 0,
1, 0, 0,
1, 0, 0,
0, 0, 1,
0, 1, 0
),
ncol = 3,  byrow = T)
osservati_test = matrix(c(0, 1, 0,
0, 1, 0,
1, 0, 0,
0, 0, 1,
0, 1, 1),
ncol = 3,  byrow = T)
MissErr(previsti_test, osservati_test)
osservati_test = c("a", "c", "a", "c")
previsti_test = c("a", "b", "a", "c")
osservati_test = c("a", "c", "a", "c")
MissErr(previsti_test, osservati_test)
# error expected
MissErr(c(1,1), c(0,0,0))
MissErr = function(previsti, osservati){
# check
if(length(previsti) != length(osservati)){
print(paste("Warning", "length(previsti) = ", length(previsti),
"; length(osservati) = ", length(osservati)))
print("return NULL")
return(NULL)
}
return( 1- sum(previsti == osservati) / length(previsti))
}
previsti_test = c("a", "b", "a", "c")
osservati_test = c("a", "c", "a", "c")
MissErr(previsti_test, osservati_test)
# error expected
MissErr(c(1,1), c(0,0,0))
#carico la libreria nnet in cui c'e' il comando class.ind che crea le
# variabili indicatrici per le modalità della risposta
library(nnet)
Y_sss = class.ind(sss$y)
USED.Loss = function(y.pred, y.test, weights = 1){
return(MissErr(y.pred, y.test))
}
# anche qua
df_err_qual = data.frame(name = NA,
misclassification = NA)
# Funzione per aggiornare il data.frame degli errori
# (inefficiente, ma amen, tanto le operazioni che deve eseguire sono sempre limitate)
# Add the error to the df_error data.frame:
# if the df_error already has a model name in name column with the same as input: update the error value
# otherwise append the new name and error
# arguments:
# @df_error (data.frame): data.frame with columns: [1]: name and [2]: error
# @model_name (char): character with the model name
# @loss_value (num): numeric with the error on the test set
# @return: df_error
Add_Test_Error = function(df_error, model_name, loss_value){
# check if the model name is already in the data.frame
is_name = model_name %in% df_error[,1]
# if yes: get the index and subscribe
if(is_name){
df_error[which(df_error[,1] == model_name),2:ncol(df_error)] = loss_value
}
else{
# get the last index
df_error[NROW(df_error) + 1,] = c(model_name, loss_value)
}
return(df_error)
}
# /////////////////////////////////////////////////////////////////
#------------------------ Stima e Verifica ------------------------
# /////////////////////////////////////////////////////////////////
# Eventualmente modificare la proporzione
id_stima = sample(1:NROW(dati), 0.75 * NROW(dati))
sss = dati[id_stima,]
vvv = dati[-id_stima,]
# In caso di convalida nell'insieme di stima
id_cb1 = sample(1:NROW(sss), 0.8 * NROW(sss))
id_cb2 = setdiff(1:NROW(sss), id_cb1)
# rimozione dataset originale
rm(dati)
# valutiamo se è sbilanciata
table(sss$y)
y_rel_freqs = table(sss$y) / NROW(sss)
y_uniques = unique(sss$y)
sorted_y_values = sort(unique(sss$y))
#carico la libreria nnet in cui c'e' il comando class.ind che crea le
# variabili indicatrici per le modalità della risposta
library(nnet)
Y_sss = class.ind(sss$y)
MissErr = function(previsti, osservati, weights = 1){
# check
if(length(previsti) != length(osservati)){
print(paste("Warning", "length(previsti) = ", length(previsti),
"; length(osservati) = ", length(osservati)))
print("return NULL")
return(NULL)
}
return( 1- sum((previsti == osservati)*weights) / length(previsti))
}
previsti_test = c("a", "b", "a", "c")
osservati_test = c("a", "c", "a", "c")
MissErr(previsti_test, osservati_test)
#weight more the first observation
MissErr(previsti_test, osservati_test, weights = c(0.4, 0.2, 0.2, 0.2))
source("lift_roc.R")
library(dplyr)
tabella.sommario = function(previsti, osservati, print_bool = FALSE){
# inizializza: per evitare casi in cui la tabella non è 2x2
n <-  matrix(0, nrow = 2, ncol = 2)
for (i in 1:length(previsti)){
if(previsti[i] == osservati[i]){
# 0 == 0 case
if (previsti[i] == 0){
n[1,1] = n[1,1] + 1
}
# 1 == 1
else{
n[2,2] = n[2,2] + 1}
}
else{
# 0 != 1
if (previsti[i] == 0){
n[1,2] = n[1,2] + 1
}
# 1 != 0
else{
n[2,1] = n[2,1] + 1
}
}
}
err.tot <- 1-sum(diag(n))/sum(n)
zeros.observed = sum(n[1,1] + n[2,1])
ones.observed = sum(n[1,2] + n[2,2])
fn <- n[1,2]/ones.observed
fp <- n[2,1]/zeros.observed
tp = 1 - fn
tn = 1 - fp
f.score = 2*tp / (2*tp + fp + fn)
if(print_bool == TRUE){
print(n)
print(c("err tot", "fp", "fn", "f.score"))
print(c(err.tot, fp, fn, f.score))}
return(round(c(err.tot, fp, fn, f.score), 4))
}
rm(list = ls())
library(dplyr)
dati = read.csv("test_datasets/df_multi.csv", sep = ",", stringsAsFactors = F)
dati = read.csv("test_datasets//df_multi.csv", sep = ",", stringsAsFactors = F)
dati = read.csv("/test_datasets/df_multi.csv", sep = ",", stringsAsFactors = F)
dati = read.csv("//test_datasets//df_multi.csv", sep = ",", stringsAsFactors = F)
ls()
dati = read.csv("/test_datasets/df_multi.csv", sep = ",", stringsAsFactors = F)
setwd("C:/Users/pietr/OneDrive - Università degli Studi di Padova/UNI/Corsi/Magistrale/Primo Anno/Secondo semestre/Data Mining/Exam used code templates/Exam Preparation Code")
dati = read.csv("/test_datasets/df_multi.csv", sep = ",", stringsAsFactors = F)
dati = read.csv("test_datasets/df_multi.csv", sep = ",", stringsAsFactors = F)
dati = read.csv("test_dataset/df_multi.csv", sep = ",", stringsAsFactors = F)
# controllo
str(dati)
