#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTestParallel = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(PPR_DF_SM),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
my_n_metrics = length(my_metrics_names)
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_id_train", "my_max_ridge_functions", "my_spline_df",
"my_weights"))
for(r in 1:my_max_ridge_functions){
sfExport(list = c("r"))
temp_metric = sfLapply(my_spline_df,
fun = function(df)
USED.Metrics(predict(mod = ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df]),
my_data[-my_id_train,]), my_data$y[-my_id_train],
weights = my_weights))
# unlist to the right dimensions matrix
metrics_array[r,,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(temp_metric)
gc()
return(metrics_array)
}
ppr_metrics_parallel = PPRRegulationTrainTestParallel(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#' @param my_ncores
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTestParallel = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(PPR_DF_SM),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
my_n_metrics = length(my_metrics_names)
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_id_train", "my_max_ridge_functions", "my_spline_df",
"my_weights"))
for(r in 1:my_max_ridge_functions){
sfExport(list = c("r"))
temp_metric = sfLapply(my_spline_df,
fun = function(df)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df]),
my_data[-my_id_train,]), my_data$y[-my_id_train],
weights = my_weights))
# unlist to the right dimensions matrix
metrics_array[r,,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(temp_metric)
gc()
return(metrics_array)
}
ppr_metrics_parallel = PPRRegulationTrainTestParallel(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
?ppr
PPR_DF_SM
PPR_DF_SM
ppr_metrics_parallel = PPRRegulationTrainTestParallel(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
warnings()
#' @param my_weights (vector of nums):
#'  same length as the difference: NROW(my_data) - length(my_id_train)
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTest = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
for(r in 1:my_max_ridge_functions){
for(df in 1: length(my_spline_df)){
mod = ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df])
metrics_array[r, df, ] = USED.Metrics(predict(mod, my_data[-my_id_train,]),
my_data$y[-my_id_train],
weights = MY_WEIGHTS)
}
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(mod)
gc()
return(metrics_ppr_array)
}
#' @param my_weights (vector of nums):
#'  same length as the difference: NROW(my_data) - length(my_id_train)
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTest = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
for(r in 1:my_max_ridge_functions){
for(df in 1: length(my_spline_df)){
mod = ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df])
metrics_array[r, df, ] = USED.Metrics(predict(mod, my_data[-my_id_train,]),
my_data$y[-my_id_train],
weights = MY_WEIGHTS)
}
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(mod)
gc()
return(metrics_ppr_array)
}
#' which is also the default
#' @param my_ncores
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTestParallel = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
my_n_metrics = length(my_metrics_names)
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_id_train", "my_max_ridge_functions", "my_spline_df",
"my_weights"))
for(r in 1:my_max_ridge_functions){
sfExport(list = c("r"))
temp_metric = sfLapply(my_spline_df,
fun = function(df)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df]),
my_data[-my_id_train,]), my_data$y[-my_id_train],
weights = my_weights))
print(temp_metric)
# unlist to the right dimensions matrix
metrics_array[r,,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(temp_metric)
gc()
return(metrics_array)
}
ppr_metrics_parallel = PPRRegulationTrainTestParallel(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
#' which is also the default
#' @param my_ncores
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTestParallel = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
my_n_metrics = length(my_metrics_names)
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_id_train", "my_max_ridge_functions", "my_spline_df",
"my_weights"))
for(r in 1:my_max_ridge_functions){
sfExport(list = c("r"))
temp_metric = sfLapply(my_spline_df,
fun = function(df)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = df),
my_data[-my_id_train,]), my_data$y[-my_id_train],
weights = my_weights))
# debug
print(temp_metric)
# unlist to the right dimensions matrix
metrics_array[r,,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(temp_metric)
gc()
return(metrics_array)
}
ppr_metrics_parallel = PPRRegulationTrainTestParallel(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES)
ppr_metrics_parallel
ppr_metrics
ppr_metrics == ppr_metrics_parallel
#' which is also the default
#' @param my_ncores
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTestParallel = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS,
my_metrics_functions = MY_USED_METRICS,
my_ncores = N_CORES){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
my_n_metrics = length(my_metrics_names)
# init parallel
sfInit(cpus = my_ncores, parallel = T)
sfExport(list = c("my_data", my_metrics_functions,
"my_id_train", "my_max_ridge_functions", "my_spline_df",
"my_weights"))
for(r in 1:my_max_ridge_functions){
sfExport(list = c("r"))
temp_metric = sfLapply(my_spline_df,
fun = function(df)
USED.Metrics(predict(ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = df),
my_data[-my_id_train,]), my_data$y[-my_id_train],
weights = my_weights))
# unlist to the right dimensions matrix
metrics_array[r,,] = matrix(unlist(temp_metric), ncol = my_n_metrics, byrow = T)
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(temp_metric)
gc()
return(metrics_array)
}
#' @param my_weights (vector of nums):
#'  same length as the difference: NROW(my_data) - length(my_id_train)
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTest = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
for(r in 1:my_max_ridge_functions){
for(df in 1: length(my_spline_df)){
mod = ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df])
metrics_array[r, df, ] = USED.Metrics(predict(mod, my_data[-my_id_train,]),
my_data$y[-my_id_train],
weights = MY_WEIGHTS)
}
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(mod)
gc()
return(metrics_ppr_array)
}
ppr_metrics = PPRRegulationTrainTest(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS)
#' @param my_weights (vector of nums):
#'  same length as the difference: NROW(my_data) - length(my_id_train)
#'
#' @return (array):
#' first dimension (with names): 1:my_max_ridge_functions
#' second dimension (with names): my_spline_df
#' third dimension (with names): my_metrics_names
#'
#' each cell contains the metric value of the model fitted on my_data[my_id_train,]
#' and tested on my_data[-my_id_train,] for each metric value used
PPRRegulationTrainTest = function(my_data = sss,
my_id_train = id_cb1,
my_max_ridge_functions = PPR_MAX_RIDGE_FUNCTIONS,
my_spline_df = PPR_DF_SM,
my_metrics_names = METRICS_NAMES,
my_weights = MY_WEIGHTS){
metrics_array = array(NA,
dim = c(my_max_ridge_functions,
length(my_spline_df),
length(my_metrics_names)),
dimnames = list(1:my_max_ridge_functions,
my_spline_df,
my_metrics_names))
for(r in 1:my_max_ridge_functions){
for(df in 1: length(my_spline_df)){
mod = ppr(y ~ .,
data = my_data[my_id_train,],
nterms = r,
sm.method = "spline",
df = my_spline_df[df])
metrics_array[r, df, ] = USED.Metrics(predict(mod, my_data[-my_id_train,]),
my_data$y[-my_id_train],
weights = MY_WEIGHTS)
}
print(paste0("n ridge functions: ", r, collapse = ""))
}
rm(mod)
gc()
return(metrics_array)
}
# valuta: se ci sono molte esplicative qualitative -> model.matrix con molti zeri
library(Matrix)
X_mm_no_interaction_sss =  sparse.model.matrix(formula_no_interaction_no_intercept, data = sss)
X_mm_no_interaction_vvv =  sparse.model.matrix(formula_no_interaction_no_intercept, data = vvv)
library(glmnet)
# criterion to choose the model: "1se" or "lmin"
cv_criterion = "lambda.1se"
lambda_vals = glmnet(x = X_mm_no_interaction_sss, y = sss$y,
alpha = 0, lambda.min.ratio = 1e-07)$lambda
ridge_no_int_best_summary = CvMetricBest(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = FALSE,
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_metric_names = METRICS_NAMES)
lambda_vals = glmnet(x = X_mm_no_interaction_sss, y = sss$y,
alpha = 0, lambda.min.ratio = 1e-07)$lambda
ridge_no_interaction_metrics = ManualCvGlmnet(my_id_list_cv = ID_CV_LIST,
my_metric_names = METRICS_NAMES,
my_x = X_mm_no_interaction_sss,
my_y = sss$y,
my_alpha = 0,
my_lambda_vals = lambda_vals,
my_weights = MY_WEIGHTS)
ridge_no_int_best_summary = CvMetricBest(my_param_values = lambda_vals,
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = FALSE,
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_metric_names = METRICS_NAMES)
ridge_no_int_best_summary
PlotAndSave(function()(
PlotCvMetrics(my_param_values = log(lambda_vals),
my_metric_matrix = ridge_no_interaction_metrics[["metrics"]],
my_se_matrix = ridge_no_interaction_metrics[["se"]],
my_best_param_values =log(ExtractBestParams(ridge_no_int_best_summary)),
my_metric_names = METRICS_NAMES,
my_main = "Ridge no interaction CV metrics",
my_xlab = " log lambda")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"ridge_no_int_metrics_plot.jpeg",
collapse = ""))
dimnames(ppr_metrics)
ppr_metrics[117,1]
ppr_metrics[17,1]
ppr_metrics[,,1][17]
ppr_metrics
names(ppr_metrics[,,1][17])
?which
