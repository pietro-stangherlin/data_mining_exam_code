var_qual_names,
FUN = function(x, y) paste(x, y, sep = ":")), collapse = " + ")
qual_qual_interactions_string = MakeSameInteractionsString(var_qual_names)
num_num_interactions_string = MakeSameInteractionsString(var_num_names)
# variabili quantitative al quadrato
num_vars_square_string = ""
if(length(var_num_names) != 0){
num_vars_square_string <- paste("I(",
var_num_names,
"^2)",
sep = "", collapse = " + ")}
# string terms vector: vector of string terms
# return formula object
MakeFormula = function(string_terms_vector, intercept_bool = TRUE){
base_formula = "y ~ "
# remove empty vector terms
string_terms_vector = string_terms_vector[which(string_terms_vector != "")]
if (intercept_bool == FALSE){
base_formula = paste(base_formula, " - 1 + ")
}
added_terms = paste(string_terms_vector, collapse = " + ")
return(as.formula(paste(base_formula, added_terms)))
}
# creazione delle formule
# per evitare errori dovuti a formule troppo lunghe
options(expressions = 50000)
formula_yes_interaction_yes_intercept <- MakeFormula(c(no_interaction_string,
num_vars_square_string,
qual_qual_interactions_string,
qual_num_interactions_string))
formula_yes_interaction_no_intercept <- MakeFormula(c(no_interaction_string,
num_vars_square_string,
qual_qual_interactions_string,
qual_num_interactions_string),
intercept_bool = FALSE)
formula_yes_interaction_yes_intercept
formula_yes_interaction_no_intercept
# formula senza interazioni
formula_no_interaction_yes_intercept = MakeFormula(no_interaction_string)
formula_no_interaction_no_intercept = MakeFormula(no_interaction_string, intercept_bool = FALSE)
formula_no_interaction_yes_intercept
formula_no_interaction_no_intercept
# /////////////////////////////////////////
# Backup data.frame + environment ---------
# ////////////////////////////////////////
save(dati,
y_index,
var_qual_index, var_qual_names,
var_num_index, var_num_names,
formula_no_interaction_no_intercept,
formula_no_interaction_yes_intercept,
formula_yes_interaction_no_intercept,
formula_yes_interaction_yes_intercept,
FIGURES_FOLDER_RELATIVE_PATH,
MODELS_FOLDER_RELATIVE_PATH,
file = "result_preprocessing.Rdata")
# if necessary delete all
# rm(list = ls())
# in case of problems: load only useful objects
# load("result_preprocessing.Rdata")
# ///////////////////////////////////
# Save output on file ---------------
# //////////////////////////////////
# text.txt -------------
# # close previoulsy opened sink (if opened) -> I should make a control
# sink()
# initialize the output .txt file to regularly write on in case
# the software crashes
# open new sink
TEXT_OUTPUT_FILE_NAME = "text_output_models.txt"
# open sink
sink(TEXT_OUTPUT_FILE_NAME, append = TRUE, split = TRUE)
# data wrangling
library(dplyr)
# parallel computing
library(snowfall)
# number of cores
N_CORES = parallel::detectCores()
load("result_preprocessing.Rdata")
#////////////////////////////////////////////////////////////////////////////
# Metrics and data.frame --------------------------------------------------
#////////////////////////////////////////////////////////////////////////////
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Quantitative response ---------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
source("loss_functions.R")
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), NA))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
filler = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
# /////////////////////////////////////////////////////////////////
#------------------------ Sottocampionamento ----------------------
# /////////////////////////////////////////////////////////////////
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Parameter tuning: cross validation on train: building cv folds  -------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
# NOTE: if the row number of sss is not a multiple of K_FOLDS
# the last fold repeats some ids from the first
# this is fixed in the code below
id_matrix_cv = matrix(SHUFFLED_ID, ncol = K_FOLDS)
# conversion of matrix in list of elements: each element contains a subset of ids
ID_CV_LIST_UNBALANCED = list()
for(j in 1:ncol(id_matrix_cv)){
ID_CV_LIST_UNBALANCED[[j]] = id_matrix_cv[,j]
}
rm(id_matrix_cv)
gc()
# repeated ids fixing
integer_division_cv = NROW_dati %/% K_FOLDS
modulo_cv = NROW_dati %% K_FOLDS
if(modulo_cv != 0){
ID_CV_LIST_UNBALANCED[[K_FOLDS]] = ID_CV_LIST_UNBALANCED[[K_FOLDS]][1:integer_division_cv]
}
ID_CV_LIST_BALANCED = ID_CV_LIST_UNBALANCED
# Balanced ID CV creation --------------
# CV_PROP = 0.5
#
#
# ID_CV_LIST_BALANCED = list()
#
# for(i in 1:length(ID_CV_LIST_UNBALANCED)){
#   # cambiare valori all'occorrenza
#   ids_few =ID_CV_LIST_UNBALANCED[[i]][which(dati$y[ID_CV_LIST_UNBALANCED[[i]]] == 1)]
#   ids_lot =ID_CV_LIST_UNBALANCED[[i]][which(dati$y[ID_CV_LIST_UNBALANCED[[i]]] == 0)]
#
#   tot = round(length(ids_few)/CV_PROP)
#
#   ID_CV_LIST_BALANCED[[i]] = c(ids_few,
#                                sample(ids_lot, size = tot - length(ids_few), replace = FALSE))
# }
#
#
#
#
#
# source("cv_functions.R")
#
# BALANCED_ID_vector = unlist(ID_CV_LIST_BALANCED)
# UNBALANCED_ID_vector = unlist(ID_CV_LIST_UNBALANCED)
source("cv_functions.R")
MY_WEIGHTS = rep(1, NROW_dati)
USE_ONLY_FIRST_FOLD = FALSE
library(nnet)
Y_dati = class.ind(dati$y)
Y_LEVELS_SORTED = colnames(Y_dati)
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Random Forest ------------------------------
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
library(ranger)
# massimo numero di esplicative presenti
RF_MAX_VARIABLES = NCOL(dati) - 2 # sottraggo 1 per la variabile risposta
RF_ITER = 400
RF_TREE_NUMBER_SEQ = seq(10, 400, 10)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
rf_cv_metrics
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
filler = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
# NOTE: if the row number of sss is not a multiple of K_FOLDS
# the last fold repeats some ids from the first
# this is fixed in the code below
id_matrix_cv = matrix(SHUFFLED_ID, ncol = K_FOLDS)
# conversion of matrix in list of elements: each element contains a subset of ids
ID_CV_LIST_UNBALANCED = list()
for(j in 1:ncol(id_matrix_cv)){
ID_CV_LIST_UNBALANCED[[j]] = id_matrix_cv[,j]
}
rm(id_matrix_cv)
gc()
# repeated ids fixing
integer_division_cv = NROW_dati %/% K_FOLDS
modulo_cv = NROW_dati %% K_FOLDS
if(modulo_cv != 0){
ID_CV_LIST_UNBALANCED[[K_FOLDS]] = ID_CV_LIST_UNBALANCED[[K_FOLDS]][1:integer_division_cv]
}
ID_CV_LIST_BALANCED = ID_CV_LIST_UNBALANCED
source("cv_functions.R")
MY_WEIGHTS = rep(1, NROW_dati)
USE_ONLY_FIRST_FOLD = FALSE
library(nnet)
Y_dati = class.ind(dati$y)
Y_LEVELS_SORTED = colnames(Y_dati)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
# massimo numero di esplicative presenti
RF_MAX_VARIABLES = NCOL(dati) - 2 # sottraggo 1 per la variabile risposta
RF_ITER = 400
RF_TREE_NUMBER_SEQ = seq(10, 400, 10)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES)
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
rf_cv_metrics
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_metric_names = METRICS_NAMES)
rf_cv_metrics
rf_cv_metrics[["metrics"]]
rf_cv_metrics[["metrics"]][,1]
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_metric_names = METRICS_NAMES)
METRICS_NAMES_PLOT = colnames(df_metrics[,2])
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = colnames(df_metrics)
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = colnames(df_metrics)[2]
METRICS_NAMES_PLOT
METRICS_NAMES_PLOT = "missclass"
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES_PLOT )
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]][,1],
my_se_matrix = rf_cv_metrics[["se"]][,1],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES_PLOT ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), 0))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
METRICS_NAMES_PLOT = "missclass"
N_METRICS = length(METRICS_NAMES)
rf_cv_metrics = ManualCvRF(my_id_list_cv_train = ID_CV_LIST_BALANCED,
my_id_list_cv_test = ID_CV_LIST_UNBALANCED,
my_metric_names = METRICS_NAMES,
my_data = dati,
my_n_variables = 2:RF_MAX_VARIABLES,
my_n_bs_trees = RF_ITER,
fix_trees_bool = TRUE,
my_weights = MY_WEIGHTS,
use_only_first_fold = USE_ONLY_FIRST_FOLD,
is_classification = TRUE,
is_multiclass = TRUE)
rf_cv_metrics_best = CvMetricBest(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_one_se_best = TRUE,
my_higher_more_complex = TRUE,
my_se_matrix = rf_cv_metrics[["se"]],
my_metric_names = METRICS_NAMES )
PlotAndSave(function()(
PlotCvMetrics(my_param_values = 2:RF_MAX_VARIABLES,
my_metric_matrix = rf_cv_metrics[["metrics"]],
my_se_matrix = rf_cv_metrics[["se"]],
my_best_param_values = ExtractBestParams(rf_cv_metrics_best),
my_metric_names = METRICS_NAMES ,
my_main = "RF CV metrics",
my_xlab = "mtry",
my_legend_coords = "bottomright")),
my_path_plot = paste(FIGURES_FOLDER_RELATIVE_PATH,
"rf_mtry_cv_metrics_plot.jpeg",
collapse = ""))
# °°°°°°°°°°°°°°°°°°°°°°° Warning: °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
USED.Metrics = function(y.pred, y.test, weights = 1){
return(c(MissErr(y.pred, y.test, weights), MissErr(y.pred, y.test, weights)))
}
# anche qua
df_metrics = data.frame(name = NA,
missclass = NA,
zero = NA)
METRICS_NAMES = colnames(df_metrics[,-1])
METRICS_NAMES_PLOT = "missclass"
N_METRICS = length(METRICS_NAMES)
# names used to extract the metric added to df_metrics
# change based on the specific problem
METRIC_VALUES_NAME = "metric_values"
METRIC_CHOSEN_NAME = "missclass"
# names used for accessing list CV matrix (actual metrics and metrics se)
LIST_METRICS_ACCESS_NAME = "metrics"
LIST_SD_ACCESS_NAME = "se"
# metrics names + USED.Loss
# WARNING: the order should be same as in df_metrics
MY_USED_METRICS = c("USED.Metrics", "MissErr")
MY_WEIGHTS = rep(1, nrow(dati))
K_FOLDS = 4
NROW_dati = NROW(dati)
SHUFFLED_ID = sample(1:NROW_dati, NROW_dati)
